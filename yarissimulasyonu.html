<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Strava Yarış Simülatörü</title>
    <script src="https://cdn.plot.ly/plotly-2.32.0.min.js"></script>
    <script src="https://cdn.jsdelivr.net/pyodide/v0.25.0/full/pyodide.js"></script>
    <!-- Leaflet Harita Kütüphanesi -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
    <style>
        body { font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif; line-height: 1.6; margin: 0; padding: 20px; background-color: #f0f2f5; }
        .container { max-width: 90%; margin: auto; } 
        .box { background: #fff; padding: 25px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); margin-bottom: 20px; }
        h1, h2 { color: #1c1e21; text-align: center; }
        .controls, .simulation-controls { text-align: center; margin: 20px 0; }
        button, input[type="file"], input[type="number"], input[type="time"], select { padding: 10px 15px; cursor: pointer; border-radius: 6px; border: 1px solid #ccc; font-size: 16px; margin: 5px; }
        #login-button { background-color: #fc4c02; color: white; border-color: #fc4c02; font-weight: bold; }
        #loader { border: 6px solid #f3f3f3; border-top: 6px solid #fc4c02; border-radius: 50%; width: 50px; height: 50px; animation: spin 1s linear infinite; margin: 20px auto; display: none; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        #status { text-align: center; font-style: italic; color: #606770; min-height: 2em; }
        #formula-display { text-align: center; font-family: 'Courier New', Courier, monospace; background-color: #f0f2f5; padding: 10px; border-radius: 4px; margin-top: 20px; }
        #model-description { text-align: center; margin-bottom: 20px; }
        #race-map { height: 450px; width: 100%; border-radius: 8px; margin-top: 30px; }
        #result-table-container { margin-top: 30px; overflow-x: auto; }
        #result-table { width: 100%; border-collapse: collapse; font-size: 14px; }
        #result-table th, #result-table td { border: 1px solid #ddd; padding: 10px; text-align: right; }
        #result-table th { background-color: #f2f2f2; font-weight: bold; }
        #result-table td:first-child, #result-table th:first-child { text-align: left; }
        #result-table a { color: #0066cc; text-decoration: none; }
        #result-table a:hover { text-decoration: underline; }
        #result-table tfoot td { font-weight: bold; background-color: #f8f8f8; }
        .hr-input-container { margin-top: 15px; }
        .hr-input-container label { margin-right: 5px; }
        #training-avg-hr-info { font-size: 14px; color: #606770; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Strava Yarış Simülatörü v1.11</h1>
        
        <div class="box" id="login-box">
            <h2>Adım 1: Strava Hesabınıza Bağlanın</h2>
            <div class="controls">
                <button id="login-button">Strava ile Bağlan</button>
            </div>
        </div>

        <div class="box" id="model-display-box" style="display: none;">
            <h2>Adım 2: Performans Modeliniz</h2>
            <p id="model-description"></p>
            <div id="model-graph"></div>
            <p id="formula-display" style="display: none;"></p>
        </div>
        
        <div class="box" id="simulation-box" style="display: none;">
            <h2>Adım 3: Yarışı Simüle Edin</h2>
            <div class="simulation-controls">
                <label for="race-gpx-input">Yarış GPX Dosyasını Yükleyin:</label>
                <input type="file" id="race-gpx-input" accept=".gpx">
                <br>
                <label for="fatigue-factor">Her 20km'de Performans Düşüşü (%):</label>
                <input type="number" id="fatigue-factor" value="5" min="0" max="50">
                 <div class="hr-input-container">
                    <label for="target-hr">Hedef Yarış Nabzı (bpm):</label>
                    <input type="number" id="target-hr" min="80" max="220" step="1" disabled>
                    <span id="training-avg-hr-info"></span>
                    <br>
                    <label for="start-time">Başlangıç Saati:</label>
                    <input type="time" id="start-time" value="07:00">
                </div>
                <br>
                <button id="simulate-button">Simülasyonu Başlat</button>
            </div>
        </div>

        <div class="box" id="result-box" style="display: none;">
            <h2>Simülasyon Sonucu</h2>
            <h3 id="estimated-time" style="text-align:center; color: #fc4c02;"></h3>
            <div id="result-graph"></div>
            <div id="result-table-container"></div>
            <div id="race-map-container" style="display:none;"><div id="race-map"></div></div>
        </div>

        <div id="status"></div>
        <div id="loader"></div>
    </div>

    <script>
        const pythonCode = `
import gpxpy, json, numpy as np
from datetime import datetime, timedelta, date
import plotly.graph_objects as go
import pandas as pd
from gpxpy.gpx import GPXWaypoint

def format_pace_mmss(seconds_per_km):
    if seconds_per_km is None or np.isnan(seconds_per_km) or seconds_per_km <= 0:
        return "--:--"
    minutes = int(seconds_per_km // 60)
    seconds = int(seconds_per_km % 60)
    return f"{minutes:02d}:{seconds:02d}"

def format_duration_hhmmss(total_seconds):
    if total_seconds is None or np.isnan(total_seconds):
        return "--:--:--"
    hours = int(total_seconds // 3600)
    minutes = int((total_seconds % 3600) // 60)
    seconds = int(total_seconds % 60)
    return f"{hours:02d}:{minutes:02d}:{seconds:02d}"

def convert_streams_to_gpx_points(streams_json):
    streams = json.loads(streams_json)
    all_points = []
    base_time = datetime.now() 
    for stream_set in streams:
        latlngs = stream_set.get('latlng', {}).get('data', [])
        alts = stream_set.get('altitude', {}).get('data', [])
        times = stream_set.get('time', {}).get('data', [])
        for i in range(len(latlngs)):
            point_time = base_time + timedelta(seconds=times[i]) if i < len(times) else None
            all_points.append(gpxpy.gpx.GPXTrackPoint(
                latitude=latlngs[i][0], longitude=latlngs[i][1],
                elevation=alts[i] if i < len(alts) else None,
                time=point_time
            ))
    return all_points

def create_performance_model(gpx_points):
    segments_data = []
    segment_length = 50.0
    outlier_threshold = 1.5
    if len(gpx_points) < 2: return None, "{}", ""
    
    gpx_for_smoothing = gpxpy.gpx.GPX()
    track = gpxpy.gpx.GPXTrack()
    segment = gpxpy.gpx.GPXTrackSegment(points=gpx_points)
    track.segments.append(segment)
    gpx_for_smoothing.tracks.append(track)
    if any(p.elevation is not None for p in gpx_points):
        gpx_for_smoothing.smooth(vertical=True, remove_extremes=True)
    
    smoothed_points = gpx_for_smoothing.tracks[0].segments[0].points
    segment_start_point, cumulative_distance = smoothed_points[0], 0.0
    
    for i in range(1, len(smoothed_points)):
        prev_point, current_point = smoothed_points[i-1], smoothed_points[i]
        delta_distance = current_point.distance_2d(prev_point)
        if delta_distance is None or delta_distance == 0: continue
        cumulative_distance += delta_distance
        if cumulative_distance >= segment_length:
            time_delta = current_point.time - segment_start_point.time if current_point.time and segment_start_point.time else None
            elevation_delta = current_point.elevation - segment_start_point.elevation if current_point.elevation and segment_start_point.elevation else 0
            slope = (elevation_delta / cumulative_distance) * 100 if cumulative_distance > 0 else 0
            pace_sec_per_km = (time_delta.total_seconds() / cumulative_distance) * 1000 if time_delta and time_delta.total_seconds() > 0 else 0
            if 120 < pace_sec_per_km < 4000:
                segments_data.append({'slope': slope, 'pace_sec': pace_sec_per_km})
            segment_start_point, cumulative_distance = current_point, 0.0
    if not segments_data: return None, "{}", ""
    
    all_slopes = np.array([d['slope'] for d in segments_data])
    all_paces = np.array([d['pace_sec'] for d in segments_data])
    kept_indices = np.arange(len(all_slopes))
    
    for _ in range(10):
        fit_slopes, fit_paces = all_slopes[kept_indices], all_paces[kept_indices]
        if len(fit_slopes) < 3: break
        poly = np.poly1d(np.polyfit(fit_slopes, fit_paces, 2))
        predicted_paces = poly(all_slopes)
        is_not_outlier_mask = (all_paces > predicted_paces / outlier_threshold) & (all_paces < predicted_paces * outlier_threshold)
        new_kept_indices = np.where(is_not_outlier_mask)[0]
        if len(kept_indices) - len(new_kept_indices) == 0: break
        kept_indices = new_kept_indices
    
    final_poly = np.poly1d(np.polyfit(all_slopes[kept_indices], all_paces[kept_indices], 2))
    fig = go.Figure()
    marker_slopes = all_slopes[kept_indices]
    marker_paces = all_paces[kept_indices]
    clean_marker_custom_data = [format_pace_mmss(p) for p in marker_paces]
    fig.add_trace(go.Scatter(x=marker_slopes, y=marker_paces, mode='markers', name='Antrenman Verileri',customdata=clean_marker_custom_data,hovertemplate='<b>Eğim: %{x:.1f}%</b><br>Pace: %{customdata}/km<extra></extra>'))
    x_smooth = np.linspace(-30, 30, 200)
    y_smooth = final_poly(x_smooth)
    line_custom_data = [format_pace_mmss(p) for p in y_smooth]
    fig.add_trace(go.Scatter(x=x_smooth, y=y_smooth, mode='lines', name='Performans Modelin', line=dict(color='red'),customdata=line_custom_data,hovertemplate='<b>Eğim: %{x:.1f}%</b><br>Model Pace: %{customdata}/km<extra></extra>'))
    a, b, c = final_poly.coeffs
    vertex_slope = -b / (2 * a) if a != 0 else 0
    slopes_to_evaluate = [-35, 35]
    if -35 < vertex_slope < 35: slopes_to_evaluate.append(vertex_slope)
    pace_values = final_poly(slopes_to_evaluate)
    y_min_model, y_max_model = pace_values.min(), pace_values.max()
    y_buffer = (y_max_model - y_min_model) * 0.05
    y_axis_min_range, y_axis_max_range = y_min_model - y_buffer, y_max_model + y_buffer
    y_min_tick, y_max_tick = int(y_axis_min_range // 30) * 30, (int(y_axis_max_range // 30) + 1) * 30
    tick_vals = np.arange(max(0, y_min_tick), y_max_tick, 30)
    tick_text = [format_pace_mmss(s) for s in tick_vals]
    fig.update_layout(title="Kişisel Eğim/Pace Performans Modelin", xaxis_title="Eğim (%)", yaxis_title="Pace (MM:SS/km)")
    fig.update_xaxes(range=[-30, 30])
    fig.update_yaxes(autorange=False, range=[y_axis_max_range, y_axis_min_range], tickvals=tick_vals, ticktext=tick_text)
    formula_string = f"Pace (sn/km) = {a:.4f} * (Eğim%)² {b:+.4f} * (Eğim%) {c:+.2f}"
    return final_poly.coeffs.tolist(), fig.to_json(), formula_string

def simulate_race(race_gpx_string, poly_coeffs, fatigue_percent, hr_adjustment_factor, start_time_str):
    gpx = gpxpy.parse(race_gpx_string)
    if any(p.elevation is not None for t in gpx.tracks for s in t.segments for p in s.points):
        gpx.smooth(vertical=True, remove_extremes=True)
    
    race_points = [p for t in gpx.tracks for s in t.segments for p in s.points]
    if not race_points: return "GPX dosyasında geçerli rota noktası bulunamadı.", go.Figure().to_json(), None, None

    start_datetime = datetime.combine(date.today(), datetime.strptime(start_time_str, '%H:%M').time())

    point_distances_km = [0.0]
    dist = 0.0
    for i in range(1, len(race_points)):
        dist += race_points[i-1].distance_2d(race_points[i])
        point_distances_km.append(dist / 1000.0)

    table_data, map_waypoint_data = [], []
    waypoint_indices = []
    process_waypoints = len(gpx.waypoints) > 2
    if process_waypoints:
        for waypoint in gpx.waypoints:
            min_dist, closest_point_index = float('inf'), -1
            for i, point in enumerate(race_points):
                dist = waypoint.distance_2d(point)
                if dist < min_dist:
                    min_dist, closest_point_index = dist, i
            if closest_point_index != -1:
                waypoint_indices.append((closest_point_index, waypoint))
        waypoint_indices.sort(key=lambda x: x[0])

    perf_model = np.poly1d(poly_coeffs)
    fatigue_factor = 1.0
    total_time_sec, cumulative_dist_m, total_gain, total_loss = 0, 0, 0, 0
    segment_length = 20.0
    profile_dist_km, profile_ele, raw_pace_sec_km = [0], [race_points[0].elevation or 0], []
    # YENİ: Kümülatif kazanç ve kayıp listeleri
    profile_gain, profile_loss = [0.0], [0.0]
    
    last_wp_dist, last_wp_time, last_wp_gain, last_wp_loss = 0, 0, 0, 0
    last_wp_name = "Start"
    last_wp_link = f"https://www.google.com/maps?q={race_points[0].latitude},{race_points[0].longitude}"
    current_wp_idx = 0

    segment_start_point = race_points[0]
    cumulative_segment_dist = 0.0
    
    for i in range(1, len(race_points)):
        prev_point, current_point = race_points[i-1], race_points[i]
        delta_dist = current_point.distance_2d(prev_point)
        if delta_dist is None or delta_dist == 0: continue
        
        cumulative_dist_m += delta_dist
        cumulative_segment_dist += delta_dist

        ele_delta = 0
        if current_point.elevation is not None and prev_point.elevation is not None:
            ele_delta = current_point.elevation - prev_point.elevation
            if ele_delta > 0: total_gain += ele_delta
            else: total_loss -= ele_delta

        if cumulative_segment_dist >= segment_length:
            if cumulative_dist_m > 20000 and (cumulative_dist_m // 20000 > (cumulative_dist_m - cumulative_segment_dist) // 20000):
                fatigue_factor *= (1 + fatigue_percent / 100)

            segment_ele_delta = 0
            if current_point.elevation is not None and segment_start_point.elevation is not None:
                segment_ele_delta = current_point.elevation - segment_start_point.elevation
            
            slope = (segment_ele_delta / cumulative_segment_dist) * 100 if cumulative_segment_dist > 0 else 0
            capped_slope = np.clip(slope, -35, 35)
            predicted_pace_sec_km = perf_model(capped_slope) * fatigue_factor * hr_adjustment_factor
            
            segment_time = predicted_pace_sec_km * (cumulative_segment_dist / 1000)
            total_time_sec += segment_time
            
            profile_dist_km.append(cumulative_dist_m / 1000)
            profile_ele.append(current_point.elevation if current_point.elevation is not None else profile_ele[-1])
            raw_pace_sec_km.append(predicted_pace_sec_km)
            # YENİ: Her adımda kümülatif kazanç/kayıp değerlerini listelere ekle
            profile_gain.append(total_gain)
            profile_loss.append(total_loss)

            segment_start_point = current_point
            cumulative_segment_dist = 0
            
        if process_waypoints and current_wp_idx < len(waypoint_indices) and i >= waypoint_indices[current_wp_idx][0]:
            wp = waypoint_indices[current_wp_idx][1]
            seg_dist, seg_time = cumulative_dist_m - last_wp_dist, total_time_sec - last_wp_time
            seg_gain, seg_loss = total_gain - last_wp_gain, total_loss - last_wp_loss
            wp_link = f"https://www.google.com/maps?q={wp.latitude},{wp.longitude}"
            
            current_total_dist_km = cumulative_dist_m / 1000
            current_total_time_str = format_duration_hhmmss(total_time_sec)
            
            arrival_datetime = start_datetime + timedelta(seconds=total_time_sec)
            day_diff = (arrival_datetime.date() - start_datetime.date()).days
            time_of_day_str = arrival_datetime.strftime('%H:%M')
            if day_diff > 0:
                time_of_day_str += f" (+{day_diff}g)"

            table_row = {
                "start_segment_name": last_wp_name, "end_segment_name": wp.name,
                "start_segment_link": last_wp_link, "end_segment_link": wp_link,
                "segment_dist_km": seg_dist / 1000, "segment_gain_m": seg_gain, "segment_loss_m": seg_loss,
                "segment_time_str": format_duration_hhmmss(seg_time),
                "segment_pace_str": format_pace_mmss(seg_time / (seg_dist/1000) if seg_dist > 0 else 0),
                "total_dist_km": current_total_dist_km, "total_gain_m": total_gain, "total_loss_m": total_loss,
                "total_time_str": current_total_time_str,
                "time_of_day_str": time_of_day_str,
                "total_pace_str": format_pace_mmss(total_time_sec / current_total_dist_km if current_total_dist_km > 0 else 0),
            }
            table_data.append(table_row)
            map_waypoint_data.append({"lat": wp.latitude, "lon": wp.longitude, "name": wp.name, **table_row})

            last_wp_dist, last_wp_time, last_wp_gain, last_wp_loss = cumulative_dist_m, total_time_sec, total_gain, total_loss
            last_wp_name, last_wp_link = wp.name, wp_link
            current_wp_idx += 1

    if process_waypoints and cumulative_dist_m > last_wp_dist:
        seg_dist, seg_time = cumulative_dist_m - last_wp_dist, total_time_sec - last_wp_time
        seg_gain, seg_loss = total_gain - last_wp_gain, total_loss - last_wp_loss
        finish_link = f"https://www.google.com/maps?q={race_points[-1].latitude},{race_points[-1].longitude}"
        
        arrival_datetime = start_datetime + timedelta(seconds=total_time_sec)
        day_diff = (arrival_datetime.date() - start_datetime.date()).days
        time_of_day_str = arrival_datetime.strftime('%H:%M')
        if day_diff > 0:
            time_of_day_str += f" (+{day_diff}g)"

        table_data.append({
            "start_segment_name": last_wp_name, "end_segment_name": "Finish",
            "start_segment_link": last_wp_link, "end_segment_link": finish_link,
            "segment_dist_km": seg_dist / 1000, "segment_gain_m": seg_gain, "segment_loss_m": seg_loss,
            "segment_time_str": format_duration_hhmmss(seg_time),
            "segment_pace_str": format_pace_mmss(seg_time / (seg_dist/1000) if seg_dist > 0 else 0),
            "total_dist_km": cumulative_dist_m / 1000, "total_gain_m": total_gain, "total_loss_m": total_loss,
            "total_time_str": format_duration_hhmmss(total_time_sec),
            "time_of_day_str": time_of_day_str,
            "total_pace_str": format_pace_mmss(total_time_sec / (cumulative_dist_m/1000) if cumulative_dist_m > 0 else 0),
        })

    # --- YENİ GRAFİK OLUŞTURMA BÖLÜMÜ ---
    result_text = f"Tahmini Bitiş Süresi: {format_duration_hhmmss(total_time_sec)}"
    pace_series = pd.Series(raw_pace_sec_km)
    moving_avg_pace_sec_km = pace_series.rolling(window=15, min_periods=1).mean().tolist()
    fig = go.Figure()

    formatted_avg_paces = [format_pace_mmss(p) for p in moving_avg_pace_sec_km]
    
    # Hover için tüm özel verileri birleştir: [pace, kazanç, kayıp]
    # 'profile_dist_km' ve diğer listeler 1 eleman fazla olduğu için [1:] ile hizalıyoruz
    full_custom_data = np.stack((
        np.array(formatted_avg_paces),
        np.array(profile_gain[1:]),
        np.array(profile_loss[1:])
    ), axis=-1)

    # Yükseklik Profili Grafiği (Yeşil Çizgi)
    fig.add_trace(go.Scatter(
        x=profile_dist_km[1:], 
        y=profile_ele[1:], 
        name='Yükseklik Profili', 
        yaxis='y2', 
        line=dict(color='darkgreen'), 
        customdata=full_custom_data, 
        hovertemplate=(
            '<b>Mesafe: %{x:.2f} km</b><br>' +
            'Yükseklik: %{y:.0f} m<br>' +
            'Ort. Pace: %{customdata[0]}/km<br>' +
            'Toplam Kazanç: +%{customdata[1]:.0f} m<br>' +
            'Toplam Kayıp: -%{customdata[2]:.0f} m<extra></extra>'
        )
    ))

    # Pace Profili Grafiği (Turuncu Çizgi)
    fig.add_trace(go.Scatter(
        x=profile_dist_km[1:], 
        y=[p / 60 for p in moving_avg_pace_sec_km], 
        name='Tahmini Ort. Pace', 
        line=dict(color='orange'), 
        customdata=full_custom_data, 
        hovertemplate=(
            '<b>Mesafe: %{x:.2f} km</b><br>' +
            'Ort. Pace: %{customdata[0]}/km<br>' +
            'Yükseklik: %{y:.0f} m<br>' +
            'Toplam Kazanç: +%{customdata[1]:.0f} m<br>' +
            'Toplam Kayıp: -%{customdata[2]:.0f} m<extra></extra>'
        )
    ))
    # --- YENİ GRAFİK OLUŞTURMA BÖLÜMÜ SONU ---

    if process_waypoints:
        wp_dists_km = [point_distances_km[idx] for idx, _ in waypoint_indices]
        wp_eles = [race_points[idx].elevation for idx, _ in waypoint_indices]
        wp_names = [wp.name for _, wp in waypoint_indices]
        fig.add_trace(go.Scatter(x=wp_dists_km, y=wp_eles, mode='markers+text', name='Kontrol Noktaları', yaxis='y2', marker=dict(color='red', size=8, symbol='circle'), text=wp_names, textposition="top center", textfont=dict(size=10), hovertemplate='<b>%{text}</b><br>Mesafe: %{x:.2f} km<br>Yükseklik: %{y:.0f} m<extra></extra>'))

    y_tickvals_min, y_ticktext_str = [], []
    if moving_avg_pace_sec_km:
        y_min_sec, y_max_sec = int(min(moving_avg_pace_sec_km)//30)*30, (int(max(moving_avg_pace_sec_km)//30)+1)*30
        y_tickvals_sec = np.arange(max(0, y_min_sec), y_max_sec, 30)
        y_ticktext_str, y_tickvals_min = [format_pace_mmss(s) for s in y_tickvals_sec], [s/60 for s in y_tickvals_sec]

    fig.update_layout(title="Yarış Simülasyonu Profili", xaxis_title="Mesafe (km)", yaxis=dict(title="Pace (MM:SS/km)", tickvals=y_tickvals_min, ticktext=y_ticktext_str), yaxis2=dict(title="Yükseklik (m)", overlaying='y', side='right'), legend=dict(x=0.5, y=-0.2, xanchor='center', yanchor='top', orientation="h"))
    
    if profile_dist_km:
        fig.update_xaxes(range=[0, profile_dist_km[-1]])

    table_json = json.dumps(table_data) if table_data else None
    map_data = {"route": [[p.latitude, p.longitude] for p in race_points], "waypoints": map_waypoint_data}
    map_data_json = json.dumps(map_data) if process_waypoints else None
    
    return result_text, fig.to_json(), table_json, map_data_json
`;

        async function main() {
            // Element referansları
            const loader = document.getElementById('loader');
            const status = document.getElementById('status');
            const loginButton = document.getElementById('login-button');
            const loginBox = document.getElementById('login-box');
            const raceGpxInput = document.getElementById('race-gpx-input');
            const fatigueFactorInput = document.getElementById('fatigue-factor');
            const targetHrInput = document.getElementById('target-hr');
            const startTimeInput = document.getElementById('start-time');
            const trainingAvgHrInfo = document.getElementById('training-avg-hr-info');
            const simulateButton = document.getElementById('simulate-button');
            const modelDisplayBox = document.getElementById('model-display-box');
            const modelDescription = document.getElementById('model-description');
            const simulationBox = document.getElementById('simulation-box');
            const resultBox = document.getElementById('result-box');
            const formulaDisplay = document.getElementById('formula-display');
            const raceMapContainer = document.getElementById('race-map-container');
            const resultTableContainer = document.getElementById('result-table-container');

            let performanceModelCoeffs = null;
            let pyodide = null;
            let trainingAvgHR = null;
            let raceMap = null;

            async function initializePyodide() {
                status.textContent = "Python ortamı hazırlanıyor...";
                loader.style.display = 'block';
                pyodide = await loadPyodide();
                await pyodide.loadPackage(["numpy", "micropip"]);
                const micropip = pyodide.pyimport("micropip");
                await micropip.install(['gpxpy', 'plotly', 'pandas']);
                pyodide.runPython(pythonCode);
                loader.style.display = 'none';
            }

            async function createCombinedModel(allActivities) {
                const twoMonthsAgo = new Date();
                twoMonthsAgo.setMonth(twoMonthsAgo.getMonth() - 2);
                const MIN_DISTANCE = 13000;
                const MAX_RUNS_FOR_MODEL = 40;

                const filteredRuns = allActivities
                    .filter(act => new Date(act.start_date) > twoMonthsAgo && act.distance > MIN_DISTANCE && ['Run', 'TrailRun', 'VirtualRun'].includes(act.sport_type))
                    .sort((a, b) => new Date(b.start_date) - new Date(a.start_date))
                    .slice(0, MAX_RUNS_FOR_MODEL);

                if (filteredRuns.length < 3) throw new Error(`Model oluşturmak için son 2 ayda 13km üzeri yeterli koşu bulunamadı (En az 3 koşu gerekli, bulunan: ${filteredRuns.length}).`);

                status.textContent = `Modeliniz için veriler çekiliyor... (${filteredRuns.length} koşu)`;
                loader.style.display = 'block';

                try {
                    const token = localStorage.getItem('strava_token');
                    const activityIds = filteredRuns.map(run => run.id);
                    const response = await fetch('/api/get_activity_streams', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${token}` },
                        body: JSON.stringify({ activity_ids: activityIds })
                    });
                    if (!response.ok) throw new Error(`Sunucu Hatası: Aktivitelerin detay verileri çekilemedi (${response.statusText})`);
                    const streams = await response.json();
                    
                    const allHeartRates = [];
                    filteredRuns.forEach((run, index) => {
                        if (run.average_heartrate && run.average_heartrate > 0) allHeartRates.push(run.average_heartrate);
                        else {
                            const stream = streams[index];
                            if (stream && stream.heartrate && stream.heartrate.data && stream.heartrate.data.length > 0) {
                                const hrStream = stream.heartrate.data;
                                const streamAvg = hrStream.reduce((sum, val) => sum + val, 0) / hrStream.length;
                                allHeartRates.push(streamAvg);
                            }
                        }
                    });

                    let avgHeartRateText = "Ortalama nabız verisi bulunamadı.";
                    if (allHeartRates.length > 0) {
                        trainingAvgHR = allHeartRates.reduce((sum, hr) => sum + hr, 0) / allHeartRates.length;
                        avgHeartRateText = `Bu model, ortalama <b>${trainingAvgHR.toFixed(0)} bpm</b> nabız ile koşulan antrenmanlara dayanmaktadır.`;
                        targetHrInput.value = Math.round(trainingAvgHR);
                        targetHrInput.placeholder = Math.round(trainingAvgHR);
                        trainingAvgHrInfo.textContent = `(Antrenman ort: ${Math.round(trainingAvgHR)} bpm)`;
                        targetHrInput.disabled = false;
                    }
                    
                    status.textContent = `Veriler analiz ediliyor...`;
                    const convertFunc = pyodide.globals.get('convert_streams_to_gpx_points');
                    const gpxPoints = convertFunc(JSON.stringify(streams));
                    const modelFunc = pyodide.globals.get('create_performance_model');
                    const [coeffs, modelFigJson, formulaString] = modelFunc(gpxPoints).toJs();
                    if (!coeffs) throw new Error("Performans modeli oluşturulamadı.");
                    
                    performanceModelCoeffs = coeffs;
                    const modelFig = JSON.parse(modelFigJson);
                    Plotly.newPlot('model-graph', modelFig.data, modelFig.layout, {responsive: true});
                    
                    modelDescription.innerHTML = `Son 2 ay içerisindeki 13km üzeri en son ${filteredRuns.length} adet koşunuz analiz edildi. <br> ${avgHeartRateText}`;
                    formulaDisplay.textContent = formulaString;
                    formulaDisplay.style.display = 'block';
                    
                    status.textContent = "Modeliniz hazır. Yarışı simüle edebilirsiniz.";
                    modelDisplayBox.style.display = 'block';
                    simulationBox.style.display = 'block';
                    setTimeout(() => Plotly.Plots.resize('model-graph'), 100);

                } catch (error) {
                    console.error("Model oluşturma hatası:", error);
                    status.textContent = `Bir hata oluştu: ${error.message}.`;
                    loginBox.style.display = 'block';
                    modelDisplayBox.style.display = 'none';
                } finally {
                    loader.style.display = 'none';
                }
            }

            function renderWaypointTable(tableData) {
                resultTableContainer.innerHTML = '';
                if (!tableData || tableData.length === 0) return;

                const table = document.createElement('table');
                table.id = 'result-table';
                const thead = table.createTHead();
                const headerRow = thead.insertRow();
                const headers = ["Segment", "Segment Süre", "Segment Pace", "Segment Mesafe", "Segment Kazanç/Kayıp", "Toplam Süre", "Varış Saati", "Toplam Pace", "Toplam Mesafe", "Toplam Kazanç/Kayıp"];
                headers.forEach(text => { const th = document.createElement('th'); th.textContent = text; headerRow.appendChild(th); });

                const tbody = table.createTBody();
                tableData.forEach(row => {
                    const tr = tbody.insertRow();
                    const cellSegment = tr.insertCell();
                    const startLink = document.createElement('a'); startLink.href = row.start_segment_link; startLink.textContent = row.start_segment_name; startLink.target = '_blank';
                    const endLink = document.createElement('a'); endLink.href = row.end_segment_link; endLink.textContent = row.end_segment_name; endLink.target = '_blank';
                    cellSegment.appendChild(startLink);
                    cellSegment.appendChild(document.createTextNode(' → '));
                    cellSegment.appendChild(endLink);
                    
                    tr.insertCell().textContent = row.segment_time_str;
                    tr.insertCell().textContent = row.segment_pace_str;
                    tr.insertCell().textContent = `${row.segment_dist_km.toFixed(2)} km`;
                    tr.insertCell().textContent = `+${Math.round(row.segment_gain_m)}m / -${Math.round(row.segment_loss_m)}m`;
                    tr.insertCell().textContent = row.total_time_str;
                    tr.insertCell().textContent = row.time_of_day_str;
                    tr.insertCell().textContent = row.total_pace_str;
                    tr.insertCell().textContent = `${row.total_dist_km.toFixed(2)} km`;
                    tr.insertCell().textContent = `+${Math.round(row.total_gain_m)}m / -${Math.round(row.total_loss_m)}m`;
                });
                
                const lastRow = tableData[tableData.length - 1];
                const tfoot = table.createTFoot();
                const totalRow = tfoot.insertRow();
                totalRow.insertCell().textContent = "Toplam";
                totalRow.insertCell().textContent = "-"; totalRow.insertCell().textContent = "-";
                totalRow.insertCell().textContent = `${lastRow.total_dist_km.toFixed(2)} km`;
                totalRow.insertCell().textContent = `+${Math.round(lastRow.total_gain_m)}m / -${Math.round(lastRow.total_loss_m)}m`;
                totalRow.insertCell().textContent = lastRow.total_time_str;
                totalRow.insertCell().textContent = lastRow.time_of_day_str;
                totalRow.insertCell().textContent = lastRow.total_pace_str;
                totalRow.insertCell().textContent = "-"; totalRow.insertCell().textContent = "-";
                resultTableContainer.appendChild(table);
            }

            function renderRaceMap(mapData) {
                raceMapContainer.style.display = 'block';
                if (raceMap) { raceMap.remove(); }
                
                raceMap = L.map('race-map');
                L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', {
                    maxZoom: 17,
                    attribution: 'Map data: © <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors, <a href="http://viewfinderpanoramas.org">SRTM</a> | Map style: © <a href="https://opentopomap.org">OpenTopoMap</a> (<a href="https://creativecommons.org/licenses/by-sa/3.0/">CC-BY-SA</a>)'
                }).addTo(raceMap);

                const routePolyline = L.polyline(mapData.route, {color: 'blue'}).addTo(raceMap);
                
                mapData.waypoints.forEach(wp => {
                    const popupContent = `
                        <b>${wp.name}</b><br>
                        Mesafe: ${wp.total_dist_km.toFixed(2)} km<br>
                        Varış Süresi: ${wp.total_time_str}<br>
                        Varış Saati: ${wp.time_of_day_str}<br>
                        Toplam Kazanç: +${Math.round(wp.total_gain_m)}m<br>
                        Toplam Kayıp: -${Math.round(wp.total_loss_m)}m
                    `;
                    L.marker([wp.lat, wp.lon]).addTo(raceMap).bindPopup(popupContent);
                });

                return routePolyline.getBounds();
            }
            
            async function handleLogin() {
                loginButton.style.display = 'none';
                loginBox.style.display = 'none';
                status.textContent = "Tüm antrenmanlarınız Strava'dan çekiliyor...";
                loader.style.display = 'block';
                try {
                    const token = localStorage.getItem('strava_token');
                    const response = await fetch('/api/get_activities', { headers: { 'Authorization': `Bearer ${token}` } });
                    if (response.status === 401) {
                        localStorage.removeItem('strava_token');
                        status.textContent = "Oturum süreniz doldu. Lütfen tekrar bağlanın.";
                        loginButton.style.display = 'block';
                        loginBox.style.display = 'block';
                        modelDisplayBox.style.display = 'none';
                        throw new Error("Unauthorized");
                    }
                    if (!response.ok) throw new Error(`API Hatası: ${response.status} ${response.statusText}`);
                    const allActivities = await response.json();
                    await createCombinedModel(allActivities);
                } catch (error) {
                    if (error.message !== "Unauthorized") {
                        console.error("Veri yükleme/Model oluşturma hatası:", error);
                        status.textContent = `Bir hata oluştu: ${error.message}. Lütfen sayfayı yenileyin.`;
                        localStorage.removeItem('strava_token');
                        loginButton.style.display = 'block';
                        loginBox.style.display = 'block';
                        modelDisplayBox.style.display = 'none';
                    }
                } finally {
                    loader.style.display = 'none';
                }
            }
            
            simulateButton.onclick = () => {
                const raceFile = raceGpxInput.files[0];
                const fatigue = parseFloat(fatigueFactorInput.value);
                const startTimeStr = startTimeInput.value;
                if (!raceFile) {
                    alert("Lütfen bir yarış GPX dosyası seçin."); return;
                }
                const targetHR = parseInt(targetHrInput.value, 10);
                if (isNaN(targetHR)) {
                    alert("Lütfen geçerli bir hedef nabız değeri girin."); return;
                }
                if (!startTimeStr) {
                    alert("Lütfen geçerli bir başlangıç saati girin."); return;
                }

                const hrPerformanceChangePerBPM = 0.009; 
                const hr_adjustment_factor = 1.0 - (targetHR - trainingAvgHR) * hrPerformanceChangePerBPM;

                status.textContent = "Yarış simüle ediliyor...";
                loader.style.display = 'block';
                resultBox.style.display = 'none';
                resultTableContainer.innerHTML = '';
                raceMapContainer.style.display = 'none';

                const reader = new FileReader();
                reader.onload = function(e) {
                    const raceGpxContent = e.target.result;
                    try {
                        const simulateFunc = pyodide.globals.get('simulate_race');
                        const [resultText, resultFigJson, tableDataJson, mapDataJson] = simulateFunc(raceGpxContent, performanceModelCoeffs, fatigue, hr_adjustment_factor, startTimeStr).toJs();
                        
                        document.getElementById('estimated-time').textContent = resultText;
                        const resultFig = JSON.parse(resultFigJson);
                        Plotly.newPlot('result-graph', resultFig.data, resultFig.layout, {responsive: true});
                        
                        if (tableDataJson) {
                            renderWaypointTable(JSON.parse(tableDataJson));
                        }
                        
                        let raceBounds = null;
                        if (mapDataJson) {
                            raceBounds = renderRaceMap(JSON.parse(mapDataJson));
                        }

                        resultBox.style.display = 'block';
                        status.textContent = "Simülasyon tamamlandı.";
                        
                        setTimeout(() => {
                            Plotly.Plots.resize('result-graph');
                            if (raceMap) {
                                raceMap.invalidateSize(); 
                                if (raceBounds) {
                                    raceMap.fitBounds(raceBounds);
                                }
                            }
                        }, 100);
                    } catch (error) {
                        console.error("Simulation error:", error);
                        status.textContent = `Simülasyon sırasında bir hata oluştu: ${error.message}`;
                        alert("Simülasyon sırasında bir hata oluştu. Lütfen konsolu kontrol edin.");
                    } finally {
                        loader.style.display = 'none';
                    }
                };
                reader.readAsText(raceFile);
            };

            await initializePyodide();

            const token = localStorage.getItem('strava_token');
            if (token) {
                handleLogin();
            } else {
                status.textContent = "Başlamak için Strava hesabınıza bağlanın.";
                loginButton.style.display = 'block';
                loginBox.style.display = 'block';
            }

            loginButton.onclick = () => { window.location.href = '/login'; };
        }

        main();
    </script>
</body>
</html>
